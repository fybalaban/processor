<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=5.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=5.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="0x1En" xml:space="preserve">
    <value>LOAD the register R with the bit pattern found in the 
memory cell whose address is XY.
Example: 0x14A3 would cause the contents of the memory 
cell located at address 0xA3 to be placed in register 0x4.</value>
  </data>
  <data name="0x1Tr" xml:space="preserve">
    <value />
  </data>
  <data name="0x2En" xml:space="preserve">
    <value>LOAD the register R with the bit pattern XY.
Example: 0x20A3 would cause the value 0xA3 to be 
placed in register 0.</value>
  </data>
  <data name="0x2Tr" xml:space="preserve">
    <value />
  </data>
  <data name="0x3En" xml:space="preserve">
    <value>STORE the bit pattern found in register R in the memory 
cell whose address is XY.
Example: 0x35B1 would cause the contents of register 
0x5 to be placed in the memory cell whose address is 
0xB1.</value>
  </data>
  <data name="0x3Tr" xml:space="preserve">
    <value />
  </data>
  <data name="0x4En" xml:space="preserve">
    <value>MOVE the bit pattern found in register R to register S.
Example: 0x40A4 would cause the contents of register 
0xA to be copied into register 0x4.</value>
  </data>
  <data name="0x4Tr" xml:space="preserve">
    <value />
  </data>
  <data name="0x5En" xml:space="preserve">
    <value>ADD the bit patterns in registers S and T as though they 
were two’s complement representations and leave the 
result in register R.
Example: 0x5726 would cause the binary values in reg&#x2;isters 0x2 and 0x6 to be added and the sum placed in 
register 0x7.</value>
  </data>
  <data name="0x5Tr" xml:space="preserve">
    <value />
  </data>
  <data name="0x6En" xml:space="preserve">
    <value>ADD the bit patterns in registers S and T as though they 
represented values in floating-point notation and leave 
the floating-point result in register R.
Example: 0x634E would cause the values in registers 0x4 
and 0xE to be added as floating-point values and the 
result to be placed in register 0x3.</value>
  </data>
  <data name="0x6Tr" xml:space="preserve">
    <value />
  </data>
  <data name="0x7En" xml:space="preserve">
    <value>OR the bit patterns in registers S and T and place the 
result in register R.
Example: 0x7CB4 would cause the result of ORing the 
contents of registers 0xB and 0x4 to be placed in register 
0xC.</value>
  </data>
  <data name="0x7Tr" xml:space="preserve">
    <value />
  </data>
  <data name="0x8En" xml:space="preserve">
    <value>AND the bit patterns in registers S and T and place the 
result in register R.
Example: 0x8045 would cause the result of ANDing the 
contents of registers 0x4 and 0x5 to be placed in register 
0x0.</value>
  </data>
  <data name="0x8Tr" xml:space="preserve">
    <value />
  </data>
  <data name="0x9En" xml:space="preserve">
    <value>XOR the bit patterns in registers S and T and place the 
result in register R.
Example: 0x95F3 would cause the result of XORing the 
contents of registers 0xF and 0x3 to be placed in register 
0x5.</value>
  </data>
  <data name="0x9Tr" xml:space="preserve">
    <value />
  </data>
  <data name="0xAEn" xml:space="preserve">
    <value>ROTATE the bit pattern in register R one bit to the right 
X times. Each time, place the bit that started at the low&#x2;order end at the high-order end.
Example: 0xA403 would cause the contents of register 
0x4 to be rotated 3 bits to the right in a circular fashion.</value>
  </data>
  <data name="0xATr" xml:space="preserve">
    <value />
  </data>
  <data name="0xBEn" xml:space="preserve">
    <value>JUMP to the instruction located in the memory cell at 
address XY if the bit pattern in register R is equal to the 
bit pattern in register number 0. Otherwise, continue 
with the normal sequence of execution. (The jump is 
implemented by copying XY into the program counter 
during the execute phase.)
Example: 0xB43C would first compare the contents of 
register 0x4 with the contents of register 0x0. If the two 
were equal, the pattern 0x3C would be placed in the 
program counter so that the next instruction executed 
would be the one located at that memory address. Oth&#x2;erwise, nothing would be done and program execution 
would continue in its normal sequence.</value>
  </data>
  <data name="0xBTr" xml:space="preserve">
    <value />
  </data>
  <data name="0xCEn" xml:space="preserve">
    <value>HALT execution.
Example: 0xC000 would cause program execution to 
stop.</value>
  </data>
  <data name="0xCTr" xml:space="preserve">
    <value />
  </data>
</root>